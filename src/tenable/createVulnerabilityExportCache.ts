import { addMinutes, getUnixTime, isAfter, sub } from "date-fns";
import { VulnerabilityExportCache } from ".";
import TenableClient from "./TenableClient";
import {
  ExportStatus,
  ExportVulnerabilitiesOptions,
  VulnerabilityExport,
  VulnerabilityState,
} from "./types";

import {
  IntegrationError,
  IntegrationLogger,
} from "@jupiterone/jupiter-managed-integration-sdk";
import { sleep } from "@lifeomic/attempt";
import pMap from "p-map";

export async function createVulnerabilityExportCache(
  logger: IntegrationLogger,
  client: TenableClient,
): Promise<VulnerabilityExportCache> {
  const vulnExports = await getVulnerabilityExports(client);
  const vulnExportMap = new Map<string, Map<number, VulnerabilityExport>>();

  logger.info(
    { vulnerabilityExports: vulnExports.length },
    "Fetched vulnerability exports",
  );

  for (const vulnExport of vulnExports) {
    let vulnMap = vulnExportMap.get(vulnExport.asset.uuid);
    if (!vulnMap) {
      vulnMap = new Map<number, VulnerabilityExport>();
    }
    vulnMap.set(vulnExport.plugin.id, vulnExport);
    vulnExportMap.set(vulnExport.asset.uuid, vulnMap);
  }

  return {
    findVulnerabilitiesExportByAssetUuid: (
      uuid: string,
    ): VulnerabilityExport[] | undefined =>
      findVulnExportsByAssetUuid(vulnExportMap, uuid),
    findVulnerabilityExportByAssetPluginUuid: (
      assetUuid: string,
      pluginId: number,
    ): VulnerabilityExport | undefined =>
      findVulnExportByAssetPluginUuid(vulnExportMap, assetUuid, pluginId),
  };
}

function findVulnExportsByAssetUuid(
  vulnExportMap: Map<string, Map<number, VulnerabilityExport>>,
  uuid: string,
) {
  const asset = vulnExportMap.get(uuid);
  if (asset) {
    return Array.from(asset.values());
  }
}

function findVulnExportByAssetPluginUuid(
  vulnExportMap: Map<string, Map<number, VulnerabilityExport>>,
  assetUuid: string,
  pluginId: number,
) {
  return vulnExportMap.get(assetUuid)?.get(pluginId);
}

async function getVulnerabilityExports(client: TenableClient) {
  // Constrain to 35 days to align with nonhistorical scan limit
  const since = getUnixTime(sub(Date.now(), { days: 35 }));
  const options: ExportVulnerabilitiesOptions = {
    num_assets: 50,
    filters: {
      since,
      state: [
        VulnerabilityState.Open,
        VulnerabilityState.Reopened,
        VulnerabilityState.Fixed,
      ],
    },
  };
  const { export_uuid: exportUuid } = await client.exportVulnerabilities(
    options,
  );
  let {
    status,
    chunks_available: chunksAvailable,
  } = await client.fetchVulnerabilitiesExportStatus(exportUuid);

  const timeLimit = addMinutes(Date.now(), 30);
  while ([ExportStatus.Processing, ExportStatus.Queued].includes(status)) {
    if (isAfter(Date.now(), timeLimit)) {
      await client.cancelVulnerabilitiesExport(exportUuid);
      throw new IntegrationError({
        code: "TenableClientApiError",
        message: `Vulnerability export ${exportUuid} failed to finish processing in time limit`,
      });
    }

    ({
      status,
      chunks_available: chunksAvailable,
    } = await client.fetchVulnerabilitiesExportStatus(exportUuid));
    await sleep(60_000); // Sleep 1 minute between status checks.
  }

  const chunkResponses = await pMap(
    chunksAvailable,
    async chunkId =>
      await client.fetchVulnerabilitiesExportChunk(exportUuid, chunkId),
    { concurrency: 3 },
  );

  const vulnerabilityExports = chunkResponses.reduce((prev, cur) => {
    return prev.concat(cur);
  }, []);

  return vulnerabilityExports;
}
